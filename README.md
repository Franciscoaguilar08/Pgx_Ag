Análisis del Pipeline Actual de la Aplicación de Farmacogenómica
Flujo Completo de la Aplicación

La aplicación de farmacogenómica del usuario implementa un pipeline de análisis multi-entrada, abarcando desde la carga de datos genómicos hasta la obtención de resultados clínicos/terapéuticos. El flujo actual admite varios tipos de entrada: archivos de variantes (como VCF, MAF o CSV), texto libre de informes de anatomía patológica, o introducción manual de variantes y biomarcadores. A continuación se detalla cada etapa del proceso:

Ingesta de Datos e Importación de Variantes

El proceso se inicia con un módulo de ingestión de datos que unifica las distintas fuentes de entrada en una representación interna común de variantes genéticas. El usuario puede subir un archivo VCF (Variant Call Format) u otros formatos tabulares de variantes (CSV/MAF) mediante la interfaz; el backend lee estos archivos y extrae las variantes relevantes. El parser actual para VCF es mínimo: itera sobre las líneas del archivo ignorando cabeceras y, al encontrar columnas cromosoma–posición–ref–alt, construye una entrada de variante de ejemplo (por defecto usa EGFR como gen y una alteración dummy si no puede inferir la real). Este comportamiento placeholder indica que el soporte completo para formatos VCF/MAF está en desarrollo – actualmente se asume un solo ejemplo (p.ej. EGFR) si el archivo no contiene anotaciones exhaustivas. Para formatos como CSV o MAF, la lógica es similar: se esperaría leer columnas de gen y cambio proteico, aunque la implementación actual está focalizada en VCF. En caso de que el usuario provea texto libre (p.ej., el informe de patología del tumor), la aplicación emplea expresiones regulares para identificar menciones de genes y variantes en el texto. Por ejemplo, detecta patrones como un símbolo de gen seguido de una mutación (p.ej. "EGFR mutación L858R"), extrayendo el gen EGFR y la alteración L858R. De igual modo, del texto puede extraer biomarcadores cualitativos como MSI-H (inestabilidad de microsatélites alta) o TMB-H (carga mutacional tumoral alta) a través de patrones predefinidos. Alternativamente, el usuario puede ingresar variantes manualmente mediante un formulario estructurado (gen, cambio proteico, etc.), las cuales el backend recibe en formato JSON y agrega a la lista de variantes a analizar.

Una vez recopiladas, todas las variantes detectadas se normalizan: el módulo de ingestión convierte los nombres de genes a mayúsculas y estandariza la notación de la proteína (quitando prefijos “p.” y usando mayúsculas para abreviaturas) para asegurar consistencia. Si el usuario proporcionó una lista manual con campos como zigosidad o frecuencia alélica, esos campos se incluyen si están disponibles. Las variantes de texto libre se agregan con los campos gene y protein_change identificados; los biomarcadores cualitativos extraídos (como MSI-H) se almacenan por separado para influir en las recomendaciones terapéuticas.

Validación de Tipo de Tumor y Genes

Paralelamente a la importación de variantes, el sistema valida la información de contexto clínico, en particular el tipo de tumor indicado y, en menor medida, la validez de los genes mencionados. El campo de tipo de tumor ingresado (por ejemplo, "adenocarcinoma de pulmón", "cáncer de colon", etc.) se compara contra una lista predefinida de diagnósticos tumorales soportados. Existe un catálogo interno TUMORES_VALIDOS que abarca neoplasias comunes (pulmón no microcítico, cáncer de mama, melanoma, etc.). La función de validación de tumor convierte el input a minúsculas y lo compara; si el tumor no se encuentra en la lista o es demasiado genérico (p.ej. simplemente "cáncer"), la API devuelve un error 400 con un mensaje apropiado y sugiere al usuario opciones válidas similares. Por ejemplo, un input "cáncer" provocaría un error indicando “Especifique el tipo de tumor (ej: 'adenocarcinoma de pulmón')” junto con algunas sugerencias concretas. Solo si el tumor es reconocido (coincidencia exacta con la lista) continúa el flujo normal, garantizando así que las interpretaciones estén contextualizadas a un tumor específico.

En cuanto a la validación de genes, actualmente no existe un listado estricto de símbolos génicos válidos en el código (no hay un GENES_VALIDOS explícito). El sistema acepta los símbolos génicos tal como se ingresan o extraen, aplicando solo normalización de formato (mayúsculas). La verificación de la validez de un gen ocurre de forma indirecta en etapas posteriores: si un gen es completamente desconocido para las bases de conocimiento (OncoKB, CIViC, etc.), simplemente no se obtendrá evidencia ni recomendaciones para él, pero la aplicación no genera un error explícito de gen inválido. Es decir, la confianza en los genes ingresados recae en el usuario y en las bases externas; no obstante, en la práctica la mayoría de genes de interés oncológico estarán cubiertos. Adicionalmente, la aplicación podría aprovechar un servicio de anotación (como Ensembl VEP) para inferir el gen a partir de coordenadas genómicas si fuera necesario – de hecho, se integra un vep_service para consultas a la API de Ensembl VEP (Variant Effect Predictor) que permitiría anotar variantes por posición, útil si el input es meramente posicional (aunque esta funcionalidad es opcional y dependiente de la disponibilidad de Internet y de la configuración).

Generación de Resultados Clínicos y Estructura de Salida

Después de la ingesta y validación, el sistema procede a analizar las variantes y biomarcadores para generar resultados clínicos o terapéuticos. Internamente, se construye una lista unificada detected_variants con todas las variantes genéticas relevantes del caso. Si el usuario proporcionó también biomarcadores (por ejemplo, estado de PD-L1, MSI, etc.), se manejan en una lista separada bios. En esta versión actual, si no se detecta ninguna variante (escenario en que quizás el informe no contenía mutaciones reconocibles y tampoco se subió VCF ni lista manual), el sistema agrega una variante de ejemplo por defecto (usualmente EGFR con alguna mutación representativa, como L858R, común en cáncer de pulmón) para no dejar vacío el resultado. Esto evidencia que la herramienta está aún en fase experimental/demostrativa: se prefiere mostrar un ejemplo educativo en lugar de retornar un resultado vacío, buscando siempre presentar al menos un output al usuario.

Con la lista final de variantes en mano, el módulo de análisis clínico evalúa cada variante contra diversas fuentes de evidencia (detalladas en la sección siguiente) y construye las acciones o recomendaciones terapéuticas pertinentes. Por cada variante se pueden generar “acciones” sugeridas – típicamente tratamientos farmacológicos específicos (terapias dirigidas, inmunoterapias, etc.), pero también podrían incluir recomendaciones de pruebas adicionales o consejos clínicos si aplicara. Cada acción resultante se representa en una estructura de datos con campos clave, por ejemplo: { "action": "Terapia dirigida", "drug": "Osimertinib", "variant": {"gene": "EGFR", "protein_change": "Ex19del"}, "mechanistic_badge": true, "strict_badge": true, "references": [ ... ] }. En esta estructura, action indica la naturaleza de la recomendación (aquí una terapia dirigida contra la alteración del EGFR), drug es el fármaco sugerido (Osimertinib), variant describe la variante que motiva la recomendación, y se incluyen banderas booleanas que señalan si la recomendación es estricta (validada por evidencia clínica fuerte en ese contexto) y/o mecanicista (basada en racional biológico pero evidencia clínica limitada). También se adjuntan referencias bibliográficas o de guías en forma de una lista de objetos con campos como label (p.ej., "NCCN 2023") y URL o identificador, lo que aporta trazabilidad a la recomendación.

El objeto de respuesta que la API devuelve al front-end típicamente contiene un resumen general y el listado de detalles por variante. Por ejemplo, un resumen podría ser: "Hallazgos: mutación EGFR Exón19del en CPNM; terapia sugerida: Osimertinib." y los detalles enumerarán cada terapia u otra acción con sus etiquetas de evidencia. En caso de errores durante el procesamiento (por ejemplo, un formato de archivo inválido, o un tumor no válido), la API devuelve un mensaje de error estructurado (código HTTP 400) con un campo detail que incluye un mensaje descriptivo y potencialmente una lista de detalles o sugerencias. Esto permite al front-end presentar un mensaje entendible al usuario (p.ej. “Tumor 'XYZ' no válido o no encontrado. Sugerencias: cáncer de mama, cáncer de próstata...”).

En síntesis, el flujo actual toma los datos genómicos ingresados, los valida y normaliza, y genera como salida un informe estructurado con variantes identificadas y recomendaciones clínicas asociadas a cada variante, distinguiendo el nivel de evidencia mediante las etiquetas estricto/mecanicista y acompañando las recomendaciones con sus fuentes de evidencia.

Modos de Análisis: Estricto vs Mecanístico

La interfaz actual de la aplicación incluye botones para alternar entre los modos "Mecanicista" y "Strict", indicando visualmente qué enfoque de interpretación aplicar a los resultados.

La aplicación ha sido diseñada con dos modos de interpretación de las variantes genómicas: el modo estricto y el modo mecanicista. Estos modos no ejecutan pipelines distintos, sino que representan filtros o etiquetas conceptuales sobre las recomendaciones terapéuticas generadas, según el grado de evidencia que las respalda:

Modo Estricto: En este enfoque, solo se consideran acciones fuertemente respaldadas por evidencia clínica en el contexto específico del tumor del paciente. Es decir, se privilegian las asociaciones variante–terapia que estén validadas por estudios clínicos robustos, guías de práctica clínica o aprobaciones regulatorias para ese tipo de cáncer. La aplicación marca estas recomendaciones con la etiqueta o “badge” de strict. Por ejemplo, una mutación EGFR Ex19del en cáncer de pulmón no microcítico tendría, en modo estricto, la recomendación de Osimertinib, ya que existe aprobación de la FDA y guías internacionales (como NCCN) que lo indican como tratamiento estándar de primera línea en ese contexto. Solo se otorgará la insignia strict_badge = true a terapias con este nivel de evidencia fuerte y concordancia de contexto: esto último significa que incluso terapias aprobadas pero fuera del contexto tumoral del paciente no contarían como estrictas. Así, el sistema aplica una política estricta (activada vía configuración) para distinguir cuándo una variante tiene una implicación terapéutica estándar en ese diagnóstico.

Modo Mecanicista: Este modo (llamado a veces exploratorio o flexible) amplía el espectro de recomendaciones incluyendo aquellas basadas en racionales biológicos o evidencia preliminar, aunque no sean estándar en la clínica para ese tumor. Se usa la etiqueta mecanicista para indicarlas. En otras palabras, si una variante sugiere una vulnerabilidad terapéutica por mecanismos moleculares conocidos, la aplicación la reportará aquí aunque la evidencia provenga solo de estudios preclínicos, casos aislados o indicaciones en otros tumores. Por ejemplo, una mutación KRAS G12D en un tumor podría no tener un fármaco aprobado en ese cáncer, pero mecánicamente se sabe que activa la vía MAPK; el modo mecanicista podría sugerir inhibidores de MEK como una posibilidad, marcada como mecanicista (no estricta) dado que es un enfoque fuera de indicación respaldado solo por racional experimental.

En la práctica, ambos modos están activos en el backend simultáneamente: cada recomendación que el sistema genera viene anotada con flags que indican si califica como estricta y/o mecanicista. De hecho, una misma recomendación puede tener ambas etiquetas a la vez cuando aplica (por ejemplo, Osimertinib para EGFR Ex19del es a la vez una terapia estricta – está aprobada – y también se basa en el mecanismo oncogénico). Actualmente, en la interfaz de usuario se muestran distintivamente (con diferentes colores o insignias) las recomendaciones estrictas versus las mecanicistas, permitiendo al usuario identificar cuáles son estándar clínico y cuáles más exploratorias. Existe un toggle UI (como muestra la imagen) para filtrar o enfatizar un modo u otro. Sin embargo, cabe notar que según la discusión previa, la conexión front-end ↔ back-end para habilitar un filtrado activo por modo podría estar pendiente de refinamiento. Es decir, la infraestructura está preparada: el backend clasifica las acciones y el front-end dispone de botones de modo, pero es posible que actualmente el sistema siempre devuelva todas las recomendaciones con sus etiquetas, dejando al usuario la interpretación visual. En futuras iteraciones se podría permitir que el usuario elija “solo mostrar recomendaciones estrictas” o “incluir mecanicistas”, ajustando así dinámicamente qué resultados ve. Por ahora, el pipeline por defecto genera todas las recomendaciones disponibles y confía en que la etiqueta Strict o Mecanicista informe al clínico sobre la naturaleza de la evidencia.

El fundamento de estos modos está alineado con las prácticas de medicina de precisión: OncoKB, por ejemplo, clasifica las alteraciones genéticas en cuatro niveles de evidencia (1, 2A, 2B, 3, 4) dependiendo de la fuerza de los datos clínicos que las vinculan con terapias
pmc.ncbi.nlm.nih.gov
. Niveles 1 y 2A corresponden a biomarcadores con implicaciones terapéuticas estándar (aprobadas por guías o FDA en esa indicación), mientras que niveles 2B, 3 y 4 engloban asociaciones investigacionales o preliminares, útiles para considerar uso off-label o ensayos clínicos
pmc.ncbi.nlm.nih.gov
. Esta misma filosofía adopta la aplicación: Modo estricto ≈ evidencias nivel 1/2A, Modo mecanicista ≈ evidencias nivel 2B/3/4. De este modo, el oncólogo puede distinguir en el informe qué recomendaciones son de uso aceptado actualmente y cuáles son sugestiones experimentales basadas en conocimientos mecanísticos de la biología tumoral.

Bases de Evidencia y Lógica de Selección Terapéutica

Un pilar central de la aplicación es la integración de bases de evidencia en oncología y farmacogenómica para fundamentar las recomendaciones. Actualmente se emplea una combinación de fuentes locales (archivos internos) y externas (APIs de bases de datos reconocidas) para reunir información sobre cada variante:

Evidencia Local (archivos clínicos internos): En el repositorio de la aplicación existe un directorio clinical_evidence/ que contiene JSONs (cancer_evidence.json y pharmgx_evidence.json) destinados a almacenar conocimiento curado internamente. La idea es permitir mapear ciertas variantes a acciones clínicas predefinidas de forma inmediata. Por ejemplo, podría haber entradas como {"nsclc": {"EGFR": {"L858R": {"actions": [ { "drug": "Osimertinib", "action": "Terapia dirigida", "refs": [...] } ] } } }. Al iniciar, la app carga estos archivos (cacheándolos) y busca cada variante en esta estructura. Si encuentra coincidencia exacta de tumor, gen y alteración, extrae la lista de acciones asociadas localmente. En la práctica actual, estos archivos están prácticamente vacíos o con datos mínimos de ejemplo, lo que sugiere que la base local aún no ha sido poblada en detalle. Por tanto, la mayor parte de la evidencia proviene de las fuentes externas en la versión actual, pero este mecanismo local ofrece la flexibilidad de agregar rápidamente nuevos conocimientos (por ejemplo, incorporar recomendaciones de un comité interno o publicaciones muy recientes) sin depender de actualizaciones de las bases externas.

OncoKB (Oncology Knowledge Base): Es una base de conocimiento desarrollada por MSKCC que anota alteraciones somáticas en cáncer con información clínica (fármacos sensibles, resistencia, niveles de evidencia, etc.). La aplicación se conecta a la API de OncoKB (vía HTTP) siempre que se disponga de un token de autenticación válido. Primero realiza una prueba de conexión (ping) para verificar que la API de OncoKB responde y que hay token configurado – en ausencia de token, marca OncoKB como no disponible pero sin interrumpir el pipeline. Para cada variante, idealmente consulta la anotación de OncoKB correspondiente (por gen, alteración y tumor). OncoKB puede devolver el nivel de evidencia de la mutación y si existe una terapia aprobada o en guías para ese perfil molecular. La lógica de la aplicación aprovecharía esta respuesta: si OncoKB indica, por ejemplo, que BRAF V600E en melanoma es nivel 1 (fármaco aprobado: vemurafenib) entonces la app añadirá Vemurafenib como terapia dirigida estricta para esa variante. Asimismo, OncoKB provee información de resistencias conocidas: p.ej. si una mutación confiere resistencia a cierto fármaco, la app podría señalar evitar ese fármaco. Actualmente, no vimos en el código una función explícita iterando variantes contra OncoKB (podría estar implementada en un método de oncokb_service no revisado aquí), pero la intención es clara dado la presencia del módulo y la configuración. OncoKB clasifica las mutaciones no solo por sensibilidad a fármacos sino también por su efecto oncogénico (oncogenic vs. benigno) y relevancia clínica; esto puede ayudar a la app a decidir si una variante es accionable o simplemente de interés académico. Dado el enfoque clínico, OncoKB es probablemente la fuente principal para seleccionar terapias estándar, al proveer mapeos directos de mutación a fármacos aprobados/ensayos en ese tumor.

CIViC (Clinical Interpretation of Variants in Cancer): La aplicación también integra CIViC, una base de conocimiento colaborativa y de acceso abierto que reúne evidencias publicadas sobre la relevancia clínica de variantes somáticas. CIViC es un recurso crowd-sourced (colaborativo) que almacena ítems de evidencia extraídos de la literatura, caracterizando la utilidad clínica de variantes en cáncer
pubmed.ncbi.nlm.nih.gov
. Mediante la API GraphQL de CIViC, el sistema consulta por gen y alteración para obtener la lista de evidence items disponibles. Estos items podrían indicar, por ejemplo: "EGFR L858R – evidencia nivel A (validada) – confiere sensibilidad a Gefitinib en CPNM" o "TP53 mutación perdida de función – pronóstico desfavorable en cáncer de ovario". La lógica de la app filtra principalmente evidencias de tipo predictivo terapéutico (ya que el foco es sugerir terapias). Si CIViC devuelve uno o varios fármacos asociados a la variante (con sus niveles de evidencia: A, B, C, etc.), la aplicación puede incorporarlos como recomendaciones. A diferencia de OncoKB, CIViC puede contener también evidencias negativas (p.ej. mutación asociada a resistencia a tal droga) – es posible que el motor de la app utilice esa información para anotar que cierta terapia no sería eficaz. Además, CIViC abarca múltiples tipos de evidencia (diagnóstica, pronóstica), por lo que en el futuro la app podría expandirse a reportar hallazgos más allá de terapia, aunque en la versión actual el foco principal son las implicaciones terapéuticas.

ClinVar/ClinGen: Se incluye un clinvar_service en el código, señal de que la aplicación puede consultar la base ClinVar de variantes germinales y su significado clínico. ClinVar es mantenida por NCBI y contiene millones de variantes anotadas con significados (benigno, patogénico, farmacogenético, etc.). Vía la API E-utilities de NCBI, el sistema podría buscar una variante específica para ver si está reportada y con qué significancia clínica. En contexto de cáncer somático, ClinVar no es tan relevante (es más para mutaciones heredables), pero podría ser útil para distinguir variantes de predisposición (p.ej. BRCA1 mutaciones germinales patogénicas) o para farmacogenética clásica (por ejemplo, DPYD variantes asociadas a toxicidad a 5-FU pueden estar en ClinVar). Por ahora, este servicio posiblemente se usa para anotar brevemente si una variante es conocida como patogénica/benigna en general, o para filtrar VUS (variantes de significado incierto) – aunque esto no afecta directamente la selección de terapia, sí aporta contexto. Es también plausible que la app use ClinVar para farmacogenómica germinal (ej: HLA-B*57:01 asociado a reacción a Abacavir, etc.), pero la integración principal de eso vendría vía PharmGKB o directrices CPIC, más que ClinVar.

PharmGKB / Farmacogenómica germinal: Dado que el nombre de la aplicación incluye “farmacogenómica”, se ha previsto la incorporación de evidencia sobre cómo variantes genéticas heredables afectan la respuesta a fármacos (ejemplos: CYP2C19 y metabolismo de clopidogrel, DPYD y toxicidad a fluorouracilo, etc.). PharmGKB es una base de datos de farmacogenética que recopila y difunde conocimiento acerca de cómo la variación genética impacta la respuesta a medicamentos
pmc.ncbi.nlm.nih.gov
. En la implementación actual, no se ve un pharmgkb_service para consulta directa a PharmGKB, sino un archivo interno pharmgx_evidence.json donde podrían haberse cargado manualmente algunas anotaciones relevantes de esa base. Posiblemente, la intención es incluir en el reporte recomendaciones como “el paciente porta TPMT heterocigoto; reducir dosis de mercaptopurina” o “HLA-B57:01 positivo; contraindicado abacavir*”, etc., derivadas de guías CPIC/FDA. Por ahora, es probable que estas recomendaciones de farmacogenética clásica sean limitadas o no aparezcan a menos que el usuario ingrese manualmente dichos datos (por ejemplo, si en biomarkers el usuario indica “DPYD deficiente”, la app podría consultar una tabla interna y sugerir evitar 5-FU). En resumen, la aplicación tiene la estructura para soportar evidencia de farmacogenómica (germinal), pero su uso actual parece ser mínimo. A medida que se agreguen datos a pharmgx_evidence.json o se integre una API, el sistema podrá incluir en los resultados este tipo de recomendaciones (marcadas quizás también como estrictas si están en etiquetas de fárbaco de la FDA).

Lógica de selección de terapias: Al analizar una variante, la aplicación combina las fuentes anteriores para determinar qué hacer con esa alteración. La jerarquía típica sería: primero, si en la evidencia local hay una acción definida (lo más específico y personalizado), se toma esa. Si no, se consulta OncoKB para ver si hay terapias estándar. Luego CIViC para cualquier evidencia adicional, y potencialmente ClinVar/PharmGKB para contextos especiales. Las acciones candidatas obtenidas se filtran por relevancia: por ejemplo, si OncoKB marca una mutación como Resistencia a fármaco X, la app podría excluir recomendar X y en su lugar anotar que existe resistencia (esto podría aparecer como una acción del tipo “Evitar terapia” o simplemente reflejado en notas). Por otro lado, si OncoKB/CIViC listan varios fármacos sensibles, la app podría incluirlos todos o priorizar según nivel de evidencia. Es aquí donde entran los modos estricto/mecanicista: las terapias con evidencia nivel 1/2A (aprobadas) se marcarán como estrictas, mientras que otras con evidencias menores o extrapoladas se marcarán solo como mecanicistas.

Un aspecto importante es cómo maneja la app múltiples variantes: Si un paciente tiene varias mutaciones driver, es posible que la aplicación sugiera múltiples terapias dirigidas (una para cada alteración) – por ejemplo, en un cáncer de colon con KRAS G12D y BRAF V600E, podría decir que no hay terapia dirigida para KRAS (salvo ensayos con inhibidores de KRAS G12C que no aplican a G12D), pero para BRAF V600E sí recomendar encarecidamente terapia anti-BRAF (combinada con anti-EGFR según guías, como viene en NCCN). La lógica implementada en este momento probablemente lista cada variante con sus acciones de forma independiente en los detalles, y en el summary podría destacar la más relevante clínicamente (quizá la de mayor impacto terapéutico).

Otro componente de la lógica es el manejo de biomarcadores cualitativos como MSI-H o TMB-H. En la actualidad, dado que el parser de texto extrae MSI-H/TMB-H, la aplicación puede tener una regla interna: si tumor es MSI-H → sugerir inmunoterapia anti-PD1 (pembrolizumab) ya que la FDA lo aprobó tumor-agnósticamente para MSI-H; si TMB muy alto → considerar también inmunoterapia. Es probable que estas reglas se implementen bien vía la evidencia local (por ejemplo, una entrada en cancer_evidence.json aplicable a “cualquier tumor” con MSI-H), o mediante código condicional tras obtener los biomarcadores. Aunque no vimos explícitamente en el fragmento de código la generación de esa recomendación, sería una extensión lógica. Por ahora, podemos asumir que la presencia de MSI-H se reflejaría en el informe quizás como un biomarcador destacado, y que una recomendación de inmunoterapia podría añadirse manualmente en la interpretación final.

En resumen, la aplicación utiliza OncoKB para identificar terapias aprobadas/guideline (estrictas) y CIViC para obtener evidencias adicionales (muchas de ellas experimentales), complementándolo con bases de farmacogenómica para recomendaciones sobre metabolizadores o marcadores especiales. La selección de terapias se hace cruzando esa información con el contexto del paciente (tipo tumoral, biomarcadores) para elegir medicamentos apropiados. Donde hay alta evidencia (por ejemplo, un biomarcador de respuesta reconocido oficialmente), la terapia se marcará como recomendación estándar; donde la evidencia es preliminar pero prometedora, se listará como opción mecanicista/investigacional. Todo ello acompañado de referencias para que el clínico pueda verificar la fuente de la recomendación, alineándose con la necesidad de tomar decisiones informadas basadas en la literatura actual
pubmed.ncbi.nlm.nih.gov
.

Integración de IA en la Aplicación

Un componente innovador de esta aplicación es la integración de Inteligencia Artificial (IA), específicamente mediante modelos de lenguaje (LLM) para asistir en la interpretación de los resultados. Actualmente, la IA se emplea de forma complementaria y controlada, en modos como:

Modo Explicativo / Definiciones: La app ofrece una función para definir términos médicos o genómicos usando IA. Por ejemplo, si en los resultados aparece un término técnico (un gen, una vía molecular, un fármaco), el usuario puede solicitar una explicación. El endpoint /ai/define toma una lista de términos y consulta a un modelo GPT externo (vía la API de OpenAI) para obtener definiciones en lenguaje natural. El prompt proporcionado al modelo incluye instrucciones explícitas: "Define los términos y agrega referencias entre [1] [2] ... sin inventar.", lo que indica que la respuesta de la IA debe incluir referencias numeradas para respaldar cada afirmación y se recalca no inventar información. Esto actúa como un control importante para evitar alucinaciones: se intenta que el modelo solo provea datos verificables. Sin embargo, dado que el LLM en esta modalidad no tiene acceso directo a una base de datos para extraer referencias reales, es probable que las "referencias" añadidas sean genéricas o previamente conocidas. En cualquier caso, esta funcionalidad está pensada como un glosario inteligente: por ejemplo, si el usuario selecciona términos como "EGFR", "Exón 19 deleción", la IA retornará algo como "EGFR: Un gen que codifica el receptor del factor de crecimiento epidérmico, mutaciones activadoras en EGFR (como deleciones en el exón 19) son frecuentes en cáncer de pulmón y confieren sensibilidad a ciertos inhibidores de tirosina kinasa [1]", donde [1] podría ser una cita de una revisión oncológica. Los controles implementados incluyen un límite de tokens de respuesta (configurado típicamente en ~900 tokens) para evitar respuestas excesivamente largas o costosas, y la exigencia de una clave API válida para habilitar cualquier funcionalidad de IA (si no se configura OPENAI_API_KEY, la ruta devuelve error 400 indicando que la IA no está habilitada). Esto significa que por defecto la IA está desactivada hasta que el administrador provea credenciales, añadiendo una capa de seguridad y costo-control.

Generación de Texto Clínico Automático: Más allá de definiciones puntuales, se ha contemplado usar la IA para generar resúmenes narrativos o interpretaciones integrales del caso clínico. Un posible “modo explicativo” sería aquel en el que, tras obtener los resultados (variante X con terapia Y sugerida), la IA redacta un párrafo estilo informe clínico: por ejemplo, "La paciente presenta un adenocarcinoma de pulmón estadio IV con mutación EGFR Ex19del. Esta alteración activa la vía del EGFR y se asocia a buena respuesta a inhibidores de tirosina quinasa; se recomienda tratamiento con Osimertinib, conforme a guías NCCN [1]." Dicho texto integraría datos concretos del paciente (diagnóstico, variantes encontradas) con conocimiento médico general. Aunque en el código proporcionado no vimos una función explícita para generar estos sumarios, es muy factible que esté en la hoja de ruta del proyecto. De implementarse, se haría con sumo cuidado: probablemente alimentando al modelo un prompt que incluya las variantes y las recomendaciones ya identificadas por la app, pidiéndole que genere una explicación cohesiva. Los controles necesarios aquí serían aún más estrictos, dado que un resumen clínico no debe contener errores: se puede restringir el modelo a solo parafrasear evidencias que la app ya halló (quizá pasándole también las referencias para que las incluya). Además, cualquier texto generado se ofrecería como ayuda al clínico, no como diagnóstico final – posiblemente mostrando un disclaimer de que es generado por IA y debe ser revisado.

IA en el Front-end: Por la naturaleza de la aplicación, la IA no toma decisiones automatizadas en el pipeline (no filtra variantes ni elige medicamentos por su cuenta), sino que actúa de cara al usuario como apoyo informativo. Esto es importante desde la perspectiva regulatoria: las recomendaciones terapéuticas vienen de bases de evidencia validadas, mientras que la IA sirve para explicar o contextualizar, nunca para sugerir algo que no esté ya respaldado por datos. El front-end incluye botones para invocar estas funciones de IA bajo demanda del usuario (p.ej., un botón “¿Por qué esta terapia?” que podría desencadenar una explicación). Todo uso de IA queda bajo supervisión del usuario, quien decide si quiere la explicación adicional, manteniendo el clínico el control de la interpretación final.

En la implementación actual, los desarrolladores han añadido las medidas de control básicas mencionadas: clave API requerida, límite de tokens, prompts cuidadosamente diseñados. No se permite que la IA opere sin restricciones – por ejemplo, si la clave falta, retorna un error indicándolo y no intenta nada. También es de esperar que se haya previsto un registro de las consultas a la IA para monitorear su contenido (por seguridad y para evitar compartir involuntariamente datos sensibles del paciente con la API externa; es probable que solo se envíen términos o resúmenes no identificatorios).

Resumiendo, la IA integrada aporta un modo explicativo y educativo a la aplicación de farmacogenómica: define términos especializados y potencialmente genera texto clínico de apoyo, todo ello con controles para asegurar que no desvirtúe la información ni opere sin el consentimiento/configuración del usuario. Es un complemento útil que puede mejorar la comprensión de los resultados por parte de médicos que no sean expertos en genómica, pero su uso está acotado y cuidadosamente vigilado en esta etapa.

Potencial de Crecimiento y Expansión del Sistema

Aunque el pipeline actual es funcional, se vislumbran múltiples vías de expansión para enriquecer la aplicación sin alterar su núcleo. La arquitectura modular existente facilita agregar nuevas etapas o integraciones. A continuación, se exploran varias oportunidades de crecimiento:

Integración de un Pipeline de Secuenciación (FASTQ → VCF)

En el estado actual, la app asume que los datos genómicos de entrada ya vienen en forma de variantes identificadas (VCF/MAF). Un paso natural de expansión sería incorporar un módulo previo de análisis de secuencias que tome datos crudos de secuenciación (archivos FASTQ) y genere los VCF de variantes automáticamente. Esto permitiría a la plataforma abarcar todo el flujo “del laboratorio al informe clínico”. Para lograrlo, se podrían integrar herramientas establecidas de bioinformática genómica: por ejemplo, el uso del pipeline GATK (Broad Institute) con su algoritmo HaplotypeCaller para llamadas de variantes germinales/somáticas, o DeepVariant de Google, un caller basado en deep learning que usa redes neuronales convolucionales para inferir genotipos a partir de lecturas de secuenciación
scinet.usda.gov
. DeepVariant ha demostrado alta precisión, convirtiendo lecturas alineadas (BAM) en VCF mediante un enfoque de aprendizaje profundo que genera “imágenes” de piles de lecturas
scinet.usda.gov
. Otra herramienta popular es FreeBayes (enfocada en variantes de polimorfismo y pequeñas indels, con un modelo bayesiano). La integración podría realizarse de manera opcional: es decir, si el usuario sube FASTQs, la app desencadena internamente (o vía un servicio externo) un workflow que incluye alineamiento al genoma de referencia (usando BWA u otro aligner), luego marcado de duplicados, llamado de variantes con la herramienta seleccionada, y finalmente alimenta el VCF resultante al módulo de análisis existente. Este proceso es computacionalmente intenso y tardado (puede llevar varias horas dependiendo del tamaño de los datos), por lo que habría que manejarlo asíncronamente (por ejemplo, notificando al usuario cuando los resultados estén listos, o integrándose con pipelines en la nube). La ventaja es que ampliaría el alcance de la aplicación a laboratorios de genómica que quieran una solución integral. Criticamente, se puede implementar sin “romper” el flujo actual ya que se agregaría como un pre-procesador: la salida seguiría siendo un VCF estándar, consumido por el pipeline existente. Así, el módulo de ingestión actual simplemente tendría una ruta adicional (además de UploadFile VCF) para manejar FASTQs, manteniendo aislada la complejidad del análisis bioinformático.

Compatibilidad con Historias Clínicas Electrónicas (EMR/HCE)

Otra dirección de crecimiento es la integración con sistemas de Historia Clínica Electrónica (HCE) o Electronic Medical Records (EMR). Actualmente, la app funciona como una herramienta standalone donde el usuario carga datos manualmente. Sin embargo, en un entorno hospitalario sería ideal que pudiera consumir datos directamente del expediente clínico y también devolver los resultados al mismo, optimizando el flujo de trabajo del médico. Para lograrlo, se podría desarrollar una API conforme a estándares sanitarios, por ejemplo utilizando HL7 FHIR (Fast Healthcare Interoperability Resources). FHIR cuenta con recursos específicos para genómica clínica, como GenomicReport, MolecularSequence y Observation para variantes genéticas. La aplicación podría exponer un endpoint seguro donde, dado un identificador de paciente o un recurso FHIR con información genómica, procese los datos y retorne un Informe de Farmacogenómica estructurado que pueda incorporarse al HCE. Asimismo, la app podría consultar la HCE para obtener automáticamente datos como el diagnóstico (tipo de tumor), el historial de tratamientos previos, o incluso resultados de secuenciación almacenados en el expediente. Esta interoperabilidad permitiría, por ejemplo, que cuando un laboratorio sube un VCF al HCE del paciente, la app lo detecte, genere las recomendaciones, y agregue una nota al expediente con ese análisis. Todo ello sin cambiar el núcleo del pipeline, sino envolviéndolo en servicios web estándar. Los desafíos aquí incluyen manejar la autenticación, seguridad HIPAA, mapping de terminologías (p.ej., que el “tipo de tumor” que viene del HCE se transforme al texto esperado por validar_tumor – posiblemente usando códigos estandarizados como ICD-O o SNOMED). No obstante, la recompensa es alta: integrar la aplicación en la práctica clínica diaria, evitando duplicación de ingreso de datos y reduciendo errores de transcripción.

IA Explicativa con Trazabilidad de Fuentes Mejorada

Si bien ya existe una integración de IA, un área de mejora es hacerla más potente y con mayor trazabilidad de fuentes. Esto implica posiblemente dotar a la IA de capacidades de Information Retrieval: por ejemplo, que al generar explicaciones o definiciones, la IA no solo escriba con base en lo que “sabe” entrenada (lo que puede conducir a referencias inventadas), sino que combine su generación de lenguaje con búsquedas reales en fuentes. Un enfoque podría ser implementar un sistema pregunta-respuesta con fuentes: dada una variante y sus recomendaciones, que el sistema busque en bases de datos (NCCN Guidelines, PubMed, etc.) las afirmaciones relevantes, extraiga fragmentos y los presente junto con la explicación generada. Esto ya se ve en algunos asistentes médicos donde la IA proporciona no solo la respuesta sino la cita exacta de la literatura de donde provino esa conclusión, garantizando transparencia. En el contexto de esta app, podría funcionar así: la app identifica que para BRCA1 mutación patogénica la recomendación es olaparib; la IA explicativa podría consultar la guía ESMO o NCCN sobre cáncer de ovario con mutación BRCA, obtener la frase “los inhibidores de PARP como olaparib han demostrado mejorar la supervivencia en pacientes con mutaciones BRCA1/2【X】”, y luego incluir esa referencia específica en la explicación al médico. Esto eleva la confianza en la información, ya que un oncólogo podría hacer clic en la referencia y leer la fuente original
pmc.ncbi.nlm.nih.gov
. Implementar esto requiere ampliar la integración de IA con un paso de búsqueda documental (usando APIs de literatura o un índice local de documentos clínicos) y luego un modelo de lenguaje que ensamble la respuesta citando esos documentos (técnica conocida como Retrieval-Augmented Generation). Los controles seguirían siendo cruciales: la app debe delimitar bien qué fuentes se consideran confiables (ej. PubMed, guías profesionales, OncoKB annotations) para evitar que la IA tome texto de cualquier sitio de internet sin verificación. Esta mejora puede añadirse modularmente – sería un módulo IA 2.0 que enriquecería el modo explicativo sin afectar el pipeline base de variantes. Como resultado, la aplicación podría ofrecer un “informe explicativo” aparte del informe estructurado: un texto continuo, con citas directas a papers o guías, explicando el significado clínico de los hallazgos del paciente.

Visualizaciones Clínicas Interactivas

Otra dimensión para expandir es la presentación de los datos y resultados mediante visualizaciones interactivas. La información genómica y terapéutica se presta a representaciones gráficas que pueden facilitar su comprensión. Algunas ideas de valor agregado incluyen:

Mapas de Vías de Señalización (Pathways): Si el paciente tiene mutaciones en ciertos genes, la aplicación podría mostrar una gráfica de la vía molecular involucrada. Por ejemplo, si hay mutaciones en PIK3CA o PTEN, destacar la vía PI3K/AKT/mTOR y señalar en qué punto ocurre la alteración. Herramientas como KEGG, Reactome o Pathway Commons podrían proveer diagramas que la app resalte. Esto ayuda al clínico a ver el contexto funcional de la mutación y entender por qué un inhibidor específico podría funcionar (mecanismo de acción). Una implementación práctica sería tener imágenes pre-renderizadas de vías clave e incrustarlas cuando correspondan; o idealmente un componente web (SVG/Canvas) donde los nodos relevantes parpadeen al seleccionar la variante.

Líneas de Tiempo (Timelines) de Tratamiento: Integrando datos de la historia clínica (o ingresados manualmente), la app podría dibujar una línea temporal del caso: diagnóstico, tratamientos administrados en fechas específicas, respuesta/resistencia, y anotar en qué punto se detectó cada variante. Esto sería valioso para oncología ya que muchas veces las variantes somáticas se interpretan en el contexto de la evolución del tumor bajo presión terapéutica (ej., la aparición de EGFR T790M tras meses de terapia con gefitinib, indicando resistencia adquirida y la necesidad de cambiar a Osimertinib). Una visualización de timeline interactiva permitiría hacer hover sobre cada hito para ver detalles (por ejemplo, “Mayo 2025: Progresión radiológica, se identifica mutación EGFR T790M en biopsia líquida”).

Gráficos de Distribución/estadísticos: A veces puede ser útil mostrar, para una mutación dada, datos poblacionales o de estudios: por ejemplo, un gráfico de barras de la frecuencia de esa mutación en distintos tumores, o un gauge del nivel de evidencia. Si OncoKB dice “Level 2A”, podría haber un pequeño gráfico indicando que es Evidencia nivel 2A de 4, para situarlo visualmente.

Estas visualizaciones se pueden implementar en el front-end aprovechando frameworks JS (D3.js, Chart.js, etc.) y consultando APIs o bases de datos para datos precomputados (como frecuencias de mutaciones en TCGA, etc.). Lo importante es que no interrumpen el pipeline ya que son representaciones derivadas de la salida ya existente. Se alimentan de los resultados (genes, tipo de tumor, terapias recomendadas) y de información estática o semi-estática. Por ejemplo, la app podría traer de antemano un JSON con definiciones de vías y qué genes participan en ellas; cuando detecta un gen de interés, cruza con esa base y muestra la figura correspondiente.

La adición de visualizaciones aportaría un elemento educativo y de análisis muy potente, ayudando a comunicar complejos conceptos de biología molecular de forma más intuitiva. Esto puede ser especialmente útil al discutir el caso en un comité de tumores, donde las imágenes valen más que tablas de texto.

Gestión de Pacientes e Histórico de Resultados

Actualmente, la aplicación parece funcionar caso por caso sin una persistencia más allá del análisis puntual (aunque existe un pgx_cache.sqlite, este se utiliza para cachear llamadas a APIs externas y acelerar respuestas, no necesariamente para almacenar pacientes). Un paso evolutivo sería dotar a la app de una verdadera gestión de pacientes y su historial genómico. Esto implica tener un backend (base de datos) donde cada paciente tenga un registro, con sus datos demográficos mínimos, su diagnóstico, y múltiples “eventos” de análisis genómico asociados (por ejemplo, secuenciaciones iniciales, biopsias de progresión, etc.). La interfaz podría entonces permitir seleccionar un paciente ya existente, ver sus análisis previos, comparar los resultados en el tiempo, e incluso generar informes acumulativos.

Para implementar esto manteniendo estable el pipeline, se puede encapsular la actual funcionalidad de análisis en una entidad “Estudio” o “Reporte”. La secuencia sería: el usuario crea un paciente (o selecciona uno ya cargado), sube un nuevo archivo o datos para ese paciente, el pipeline corre como de costumbre y genera un informe de resultados que se guarda en la base de datos asociado a la fecha y al paciente. Posteriormente, se puede consultar ese informe sin recalcular (a menos que se desee actualizar con nuevas bases de evidencia). También permitiría realizar comparación entre informes: si en enero el paciente tenía mutaciones A y B, y en junio aparecen A y C, se podría resaltar que B desapareció (quizá por presión terapéutica) y que C emergió nueva, lo cual puede indicar un cambio en la biología del tumor. Tener múltiples puntos temporales en la app abre la puerta a análisis longitudinales – e.g., graficar la clonalidad de mutaciones en el tiempo, o listar qué tratamientos recibió el paciente entre un análisis y otro y cómo eso se correlaciona con las mutaciones observadas.

La gestión de pacientes también conlleva consideraciones de autenticación y privacidad: seguramente habría que implementar cuentas de usuario, roles (un clínico solo ve sus pacientes, etc.), y cifrado de datos sensibles. Desde el punto de vista técnico, agregar un módulo de persistencia (posiblemente ampliando el SQLite a un esquema más complejo o migrando a una base de datos clínica) no interfiere con el pipeline, sino que lo complementa. Se podría seguir la arquitectura de guardar al final – es decir, primero ejecutar el pipeline en memoria como ahora, y luego serializar el resultado y guardarlo. O viceversa, permitir re-ejecutar un pipeline guardado (por ejemplo, si nuevas evidencias aparecen, recalcular un informe antiguo con las nuevas bases).

En conclusión, el sistema tiene amplio potencial de mejora incremental en diversos frentes. Añadir un módulo de calling de variantes expandirá su alcance aguas arriba hacia datos crudos; integrarse con HCE lo hará más útil en la clínica diaria; potenciar la IA explicativa con fuentes lo hará más confiable y valioso educativamente; visualizaciones interactivas facilitarán la interpretación de los datos complejos; y una gestión de pacientes e históricos convertirá la app en una plataforma completa de apoyo a decisiones en oncología de precisión. Importantly, todas estas mejoras pueden incorporarse manteniendo el flujo principal – que ya está bien definido (input → variantes → evidencias → salida) – y actuando ya sea antes (pre-procesamiento), después (post-procesamiento y visualización) o en paralelo (capas de IA, integraciones) sin romper la funcionalidad existente. Con un desarrollo modular y progresivo, la aplicación podría transformarse en un ecosistema integral de farmacogenómica clínica, adaptado tanto para investigación traslacional como para su uso en la práctica médica rutinaria, siempre conservando la trazabilidad de la información y la confianza en las recomendaciones proporcionadas.
